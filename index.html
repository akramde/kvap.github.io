<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8" />
<title>Video Fetcher - Smart Crawler</title>
<style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; direction: rtl; background-color: #f4f4f9; padding: 20px; }
    .input-group { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 20px; }
    label { display: block; margin-top: 10px; font-weight: bold; font-size: 14px; color: #555; }
    input { width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
    button { margin-top: 20px; padding: 12px 20px; background-color: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; font-weight: bold; }
    button:hover { background-color: #59359a; }
    
    .source { background: white; margin: 15px 0; padding: 15px; border-right: 5px solid #28a745; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-radius: 4px; }
    .source h3 { margin-top: 0; color: #28a745; border-bottom: 1px solid #eee; padding-bottom: 10px; }
    
    .link-item { margin-bottom: 8px; padding: 10px; background: #f8f9fa; border-radius: 4px; border: 1px solid #e9ecef; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap;}
    .link-info { flex: 1; word-break: break-all; }
    .link-item a { text-decoration: none; color: #007bff; font-weight: bold; display: block; margin-top: 5px; font-size: 13px; }
    
    .tag { padding: 3px 8px; font-size: 11px; border-radius: 4px; color: white; font-weight: normal; margin-left: 5px; display: inline-block;}
    .tag-video { background-color: #28a745; }
    .tag-page { background-color: #fd7e14; }
    .tag-sub { background-color: #17a2b8; }
    
    .status { font-size: 11px; padding: 2px 6px; border-radius: 4px; color: white; margin-right: 5px; }
    .st-wait { background-color: #999; }
    .st-ok { background-color: #198754; }
    .st-err { background-color: #dc3545; }

    .loader { display: none; text-align: center; margin-top: 20px; color: #555; }
</style>
</head>
<body>

<h2>المستخرج الذكي (بدون تحميل خلفي)</h2>

<div class="input-group">
    <label>ID: <input id="id" value="1309012" /></label>
    <label>IMDB ID: <input id="imdb" value="tt32123395" /></label>
    <label>Kinopoisk ID: <input id="kp_id" value="6638362" /></label>
    <label>الاسم: <input id="title" value="Альтер" /></label>
    <label>الاسم الأصلي: <input id="orig_title" value="Altered" /></label>
    <label>السنة: <input id="year" value="2025" /></label>
</div>

<button type="button" onclick="startProcess()">بدء العملية</button>

<div id="loader" class="loader">جاري العمل... <span id="status-text"></span></div>
<div id="output"></div>

<script>
const parser = new DOMParser();

async function startProcess(){
  const params = {
      id: document.getElementById('id').value,
      imdb: document.getElementById('imdb').value,
      kp_id: document.getElementById('kp_id').value,
      title: encodeURIComponent(document.getElementById('title').value),
      orig_title: encodeURIComponent(document.getElementById('orig_title').value),
      year: document.getElementById('year').value
  };
  
  const outputDiv = document.getElementById('output');
  const loader = document.getElementById('loader');
  const statusText = document.getElementById('status-text');

  outputDiv.innerHTML = '';
  loader.style.display = 'block';
  statusText.textContent = 'جلب المصادر...';

  const base = `https://lam.maxvol.pro/lite/events?life=true&id=${params.id}&imdb_id=${params.imdb}&kinopoisk_id=${params.kp_id}&title=${params.title}&original_title=${params.orig_title}&year=${params.year}`;

  try {
      const res = await fetch(base);
      const j1 = await res.json();
      if(!j1.memkey) throw new Error("No memkey");
      
      const lifeUrl = `https://lam.maxvol.pro/lifeevents?memkey=${j1.memkey}`;
      const res2 = await fetch(lifeUrl);
      const j2 = await res2.json();

      const sources = j2.online.filter(s => s.show);
      
      if(sources.length === 0) {
          loader.style.display = 'none';
          outputDiv.innerHTML = '<div style="color:red">لا توجد مصادر.</div>';
          return;
      }

      statusText.textContent = `فحص ${sources.length} مصدر...`;

      // معالجة المصادر بالتوالي أو التوازي
      const promises = sources.map(async (s) => {
        const infoUrl = `${s.url}?id=${params.id}&imdb_id=${params.imdb}&kinopoisk_id=${params.kp_id}&title=${params.title}&original_title=${params.orig_title}&year=${params.year}`;
        
        try {
            // هنا يبدأ السحر: دالة processUrl تقرر هل تفتح الرابط أم لا
            const items = await processUrl(infoUrl, s.name, 0);
            return { source: s, items: items };
        } catch (e) {
            return { source: s, error: e.message };
        }
      });

      const results = await Promise.all(promises);
      loader.style.display = 'none';
      renderResults(results, outputDiv);

  } catch (e) {
      loader.style.display = 'none';
      outputDiv.innerHTML = `<div style="color:red">خطأ: ${e.message}</div>`;
  }
}

/**
 * الدالة الذكية: تقرر هل الرابط فيديو (للعرض فقط) أم صفحة (للفتح والاستخراج)
 */
async function processUrl(url, sourceName, depth) {
    if (depth > 2) return [];

    // 1. الفحص السريع بالامتداد (Static Check)
    if (isVideoExtension(url)) {
        return [createItem(url, "فيديو مباشر (من الامتداد)", "video")];
    }

    try {
        // 2. الفحص عبر الشبكة (HEAD Request) للتأكد من النوع دون التحميل
        // نستخدم AbortController لقطع الاتصال بسرعة إذا تأخر
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 4000); // 4 ثواني مهلة

        // نحاول جلب المحتوى. إذا كان المصدر Lite/JSON، عادة يرجع نص بسرعة.
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);

        // التحقق من نوع المحتوى قبل قراءة النص
        const contentType = response.headers.get("content-type");
        
        // إذا كان السيرفر يقول أن هذا فيديو، توقف فوراً ولا تقرأ النص!
        if (contentType && (contentType.includes("video") || contentType.includes("mpegurl") || contentType.includes("octet-stream"))) {
            return [createItem(url, "فيديو (تم كشفه من الهيدر)", "video")];
        }

        // إذا وصلنا هنا، فالرابط غالبًا JSON أو HTML، يمكننا قراءته بأمان
        const html = await response.text();
        const doc = parser.parseFromString(html, 'text/html');
        const elements = doc.querySelectorAll('[data-json]');
        
        let extracted = [];
        let subLinks = []; // روابط للصفحات الفرعية

        // إذا لم نجد عناصر data-json وكان النص يحتوي على روابط فيديو مباشرة (Regex)
        // هذا يعني أننا ربما فتحنا قائمة تشغيل m3u8 كنص بالخطأ، أو صفحة بسيطة
        if (elements.length === 0) {
             const regexLinks = [...html.matchAll(/https?:\/\/[^"'<>\s]+\.(mpd|m3u8|mp4)/g)];
             if (regexLinks.length > 0) {
                 regexLinks.forEach(m => extracted.push(createItem(m[0], "رابط Regex", "video")));
                 return extracted; // انتهينا
             }
        }

        // تحليل JSON المستخرج
        elements.forEach(el => {
            try {
                let jsonStr = el.getAttribute('data-json');
                if(!jsonStr) return;
                jsonStr = jsonStr.replace(/&quot;/g, '"');
                const obj = JSON.parse(jsonStr);
                
                let label = obj.title || obj.translate || 'ملف';
                if(obj.voice_name) label += ` (${obj.voice_name})`;
                if(obj.maxquality) label += ` [${obj.maxquality}]`;

                // دالة مساعدة لإضافة الرابط المناسب
                const handleLink = (linkUrl, linkLabel, typeOverride) => {
                    if (!linkUrl) return;
                    
                    // إذا كان رابط فيديو صريح
                    if (isVideoExtension(linkUrl) || typeOverride === 'video') {
                        extracted.push(createItem(linkUrl, linkLabel, "video"));
                    } 
                    // إذا كان رابط تصفح (مجلد/موسم)
                    else {
                        // نضيفه لقائمة الروابط التي سنفتحها لاحقاً
                        subLinks.push({ url: linkUrl, label: linkLabel });
                    }
                };

                // فحص الحقول
                if (obj.url) handleLink(obj.url, label);
                if (obj.stream) handleLink(obj.stream, label, "video"); // stream غالبا فيديو
                
                if (obj.quality) {
                    Object.keys(obj.quality).forEach(q => handleLink(obj.quality[q], `${label} [${q}]`, "video"));
                }
                
                if (obj.subtitles) {
                    obj.subtitles.forEach(s => extracted.push(createItem(s.url, `ترجمة: ${s.label}`, "subtitle")));
                }

            } catch(e) {}
        });

        // 3. التكرار (Recursion): فتح روابط التصفح التي وجدناها
        if (subLinks.length > 0) {
            const promises = subLinks.map(sub => processUrl(sub.url, sourceName, depth + 1));
            const subResults = await Promise.all(promises);
            subResults.forEach(res => extracted = extracted.concat(res));
        }

        return extracted;

    } catch (e) {
        // في حالة الخطأ أو التايم أوت، نعتبر الرابط تالف أو غير قابل للقراءة
        return [];
    }
}

function isVideoExtension(url) {
    if(!url) return false;
    // قائمة الامتدادات التي نعتبرها فيديو 100% ولا نحتاج لفتحها
    return /\.(mp4|mkv|m3u8|mpd|avi|mov|flv|webm)(\?|$)/i.test(url);
}

function createItem(url, label, type) {
    if(url && url.includes(" or ")) url = url.split(" or ")[0].trim();
    return { url: url, label: label, type: type };
}

function renderResults(results, container) {
    results.forEach(item => {
        if(item.error) return;
        
        // إزالة التكرار
        const unique = [];
        const map = new Map();
        item.items.forEach(i => {
            if(!map.has(i.url)) { map.set(i.url, true); unique.push(i); }
        });

        if(unique.length === 0) return; // لا تعرض المصادر الفارغة

        const box = document.createElement('div');
        box.className = 'source';
        
        let html = unique.map((u, idx) => {
            const uid = `lnk-${Math.random().toString(36).substr(2, 9)}`;
            
            let tagHTML = '';
            if(u.type === 'video') {
                tagHTML = '<span class="tag tag-video">فيديو</span>';
                // نتحقق من صلاحية الرابط فقط (Ping) بدون تحميل
                validateLink(u.url, uid);
            } else if(u.type === 'subtitle') {
                tagHTML = '<span class="tag tag-sub">ترجمة</span>';
            } else {
                tagHTML = '<span class="tag tag-page">صفحة</span>';
            }

            return `
            <div class="link-item">
                <div class="link-info">
                    <div>
                        ${tagHTML}
                        <span id="st-${uid}" class="status st-wait" style="display:${u.type==='video'?'inline-block':'none'}">فحص...</span>
                        <strong>${u.label}</strong>
                    </div>
                    <a href="${u.url}" target="_blank">${u.url}</a>
                </div>
            </div>`;
        }).join('');

        box.innerHTML = `<h3>${item.source.name} <small>(${unique.length})</small></h3><div>${html}</div>`;
        container.appendChild(box);
    });
}

// دالة التحقق الخفيفة جداً (Ping)
async function validateLink(url, id) {
    const el = document.getElementById(`st-${id}`);
    if(!el) return;

    try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 5000);
        
        // HEAD request فقط - لا يحمل البدي
        await fetch(url, { method: 'HEAD', mode: 'no-cors', signal: controller.signal });
        
        clearTimeout(timeout);
        el.textContent = "متاح";
        el.className = "status st-ok";
    } catch {
        el.textContent = "غير متاح";
        el.className = "status st-err";
    }
}
</script>

</body>
</html>
